### 核心思想 ###

- 算法大致流程是用一个队列来进行维护，初始时将源点加入队列。
- 每次从队列中出队一个元素，标记其不在队列中，并对所有与他相邻的点（最好用邻接表存储）进行松弛。
- 若某个相邻的点松弛成功并且不在队列中，则将其入队，直到队列为空时算法结束。
- Bellman允许多次入队，一个点松弛过其它的点之后，过了一段时间可能本身被改进，于是可以再次用来松弛。
- 设一个点用来作为迭代点（入队）对其它点进行松弛的平均次数为k，有办法证明对于通常的情况，k在2左右。

### 对比Dijkstra ###

- 上述方式导致了BF效率的不稳定性，而Dijkstra的效率则会高一些。
- 而与Dijkstra的区别在于，Dijkstra是每次取最近的点来松弛其他所有，而Bellman则是不断松弛。
- 但是也是由于这个，使得BF没有利用贪心的性质，可以判断是否存在负环。
- 判断负环的方法：对于朴素版BF实现，当算法循环n-1次后，如果还能找到松弛，证明存在负环。
- 对于SPFA实现，可以用数组记录所有点的入队次数，若一个点入队次数超过n，则有负权环。