# 匈牙利算法核心思想 #

### 定义 ###

> 设G=(V,E)是一个无向图，如果顶点V可分割为两个互不相交的子集(U,V)，并且图中的每条边（i，j）所关联的两个顶点i和j分别属于这两个不同的顶点集(i in U,j in V)，则称图G为一个二分图。

> 一个图是一个匹配（或称独立边集）是指这个图之中，任意两条边都没有公共的顶点。这时每个顶点都至多连出一条边，而每一条边都将一对顶点相匹配。

> 若P是图G中一条连通两个未匹配顶点的路径，并且属于M的边和不属于M的边(即已匹配和待匹配的边)在P上交替出现，则称P为相对于M的一条增广路径。 

### 主要思想 ###

- 匈牙利算法用于求出二分图的最大匹配，即求出一个边集，使得任何两条边没有关联到同一个点上。而方法则是不断寻找增广路径。
- 首先用邻接表建图，为了简便可以采用二维矩阵，第零元素用于存储邻接点个数；
- 使用一个match数组记录每个点是否未被覆盖（即没有被匹配中的边关联）；使用visited数组记录每次DFS时每个点是否被访问过。
- 下面开始从每一个点寻找增广路。对于某一个点u，访问它的所有未被访问过的邻接点，如果这个邻接点没有被覆盖或者被覆盖之后从这个点出发能够找到增广路径，那么从u到这个点就构成一条增广路径，其两个端点都未被覆盖。
- 如果用DFS找到了这样一条路径，一路上的点就都被标记为覆盖了，然后将匹配数加一。
- 这样一直下去，直到遍历了所有点为止。

### 伪代码 ###
    bool 寻找从k出发的对应项出的可增广路
    {
        while (从邻接表中列举k能关联到顶点j)
        {
            if (j不在增广路上)
            {
                把j加入增广路;
                if (j是未盖点 或者 从j的对应项出发有可增广路)
                {
                    修改j的对应项为k;
                    则从k的对应项出有可增广路,返回true;
                }
            }
        }
        则从k的对应项出没有可增广路,返回false;
    }
    
    void 匈牙利hungary()
    {
        for i->1 to n
        {
            if (则从i的对应项出有可增广路)
                匹配数++;
        }
        输出 匹配数;
    }